# 10.1 프로세스 설명
## 10.1.1 프로세스 개념과 종류
### 프로세스
- 실행중인 프로그램
- 처음에 부팅할 때는 systemd (구 init)을 실행해 최초의 사용자 프로세스를 생성

|항목|설명|
|---|---|
|부모 프로세스|다른 프로세스를 생성할 수 있는 프로세스|
|자식 프로세스|부모 프로세스로부터 만들어지는 프로세스|
|데몬 프로세스|일반적으로 사용자가 직접 실행시키지 않고, 커널에 의해 구동되며 백그라운드에서 특정 서비스를 제공하기 위해 구동됨. 파일 이름의 끝에 d를 붙여서 사용하는 것이 일반적|
|고아 프로세스|자식 프로세스는 작업이 종료되면 부모 프로세스로 돌아가는데, 그 전에 부모 프로세스가 종료된 경우. 이 때는 init 프로세스가 해당 프로세스가 종료될 수 있게 해줌|
|좀비 프로세스|Defunct 프로세스로 알려져 있으며, 자식 프로세스가 종료를 위해 프로세스 리스트라 불리우는 목록에서 종료 승인을 대기하고 있는 상태에 있는 프로세스. 즉, 이미 종료된 ㅍ ㅡ로세스지만 리소스 반환을 하지 못한 상태로 남아있는 프로세스|

### PID, PPID
- 자식 프로세스와 부모 프로세스의 관계 확인
`PID`: 프로세스 번호
`PPID`: 자식 프로세스의 부모 프로세스 번호

# 10.2 프로세스 확인
### ps 명령어 사용
```
[vagrant@user01 ~]$ ps # 프로세스 확인
    PID TTY          TIME CMD
   3508 pts/0    00:00:00 bash
   3719 pts/0    00:00:00 ps
```
- `PID`: PID
- `TTY`: 현재 터미널을 의미
- `TIME`: 해당 프로세스가 사용한 CPU 시간
- `CMD`: 실행된 명령 이름

### 시스템 전체 프로세스 출력
|옵션|설명|
|---|---|
|-f|상세한 정보 출력. PPID와 STIME 등의 추가 정보 확인 가능|
|-e|시스템 상의 모든 프로세스 정보 출력|
```
ps -ef | more
```

### 특정 프로세스의 검색
```
# vagrant 포함된 프로세스만 찾음

[vagrant@user01 ~]$ ps aux | grep vagrant 
root        3486  0.0  1.1  20288 11520 ?        Ss   02:36   0:00 sshd: vagrant [priv]
vagrant     3490  0.0  1.4  23792 13844 ?        Ss   02:36   0:00 /usr/lib/systemd/systemd --user
vagrant     3493  0.0  0.9 109604  8964 ?        S    02:36   0:00 (sd-pam)
vagrant     3507  0.0  0.7  20464  7276 ?        S    02:36   0:00 sshd: vagrant@pts/0
vagrant     3508  0.0  0.5   8872  5376 pts/0    Ss   02:36   0:00 -bash
vagrant     3735  0.0  0.3  10144  3456 pts/0    R+   07:06   0:00 ps aux
vagrant     3736  0.0  0.2   6404  2048 pts/0    S+   07:06   0:00 grep --color=auto vagrant
```
### pstree/ptree 명령어 사용
- 부모 프로세스와 자식 프로세스 사이의 관계를 트리 형태로 확인
```
[vagrant@user01 ~]$ pstree -p
systemd(1)─┬─NetworkManager(2794)─┬─{NetworkManager}(2800)
           │                      └─{NetworkManager}(2802)
           ├─agetty(676)
           ├─atd(663)
           ├─auditd(567)─┬─sedispatch(569)
           │             ├─{auditd}(568)
           │             └─{auditd}(570)
          ...
```
### top 명령어
- 메모리 사용량, CPU 사용량, 프로세스 정보 등을 실시간으로 모니터링
```
top - 07:14:48 up  5:24,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 119 total,   1 running, 118 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.2 hi,  0.0 si,  0.0 st
MiB Mem :    941.1 total,    485.3 free,    387.2 used,    216.8 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.    553.9 avail Mem
```

# 10.3 시그널 사용
## 시그널
- 프로세스는 메모리에 존재하는  프로그램의 형태이므로 이를 관리하기 위해서 시그널을 사용

|시그널 번호|시그널 이름|동작|정의
|---|---|---|---|
|1|SIGHUP|Hang up|프로세스 종료 없이 프로그램을 새로 초기화|
|2|SIGINT|Interrupt|Interrupt 시그널은 `Ctrl + C`를 사용할 때 발생|
|9|SIGKILL|Kill|프로세스는 kill 시그널을 무시할 수 없으며 프로세스가 종료됨|
|15|SIGTERM|Terminate|프로세스를 종료함. 일부 프로세스는 이 시그널을 무시하며, kill 또는 pkill 같은 명령어의 기본 시그널이기도 함|

### 시그널 목록 확인
```
[vagrant@user01 ~]$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```
### 강제 종료
```
kill -pid
```
### 실행중 프로세스 확인
```
jobs
```

# 10.4 작업 관리    
## 작업
- 쉘이 관리하는 프로세스. 쉘은 작업들을 동작시키거나 조작할 수 있으며, 각 작업마다 작업 ID 번호를 할당하며 동시에 여러 작업들을 동작시킬 수 있음
### 작업 상태
`Foreground jobs`: 터미널에서 명령어를 실행할 때 명령어 실행이 종료될 때까지 터미널 화면을 사용하여 동작하는 것
`Background jobs`: 명령어의 끝에 '&' 기호를 입력하면 명령어는 터미널 화면을 사용하지 않고 실행됨
`Stopped jobs`: 포그라운드 작업에서 `Ctrl + Z`를 누르거나, 백그라운드 작업에서 stop 명령어를 입력하면 작업이 정지됨

## 백그라운드 프로세스 실행
```
# 300초 동안 대기하고, 그 프로세스를 백그라운드에서 시행
sleep 300 & 
```

## 작업 목록 확인
```
jobs
```

## 백그라운드 작업을 포그라운드로 이동
```
fg %1
```

## 포그라운드 작업을 백그라운드로 이동
```
bg %1
```

## 백그라운드 작업 정지
```
stop %1
```
- csh, ksh에서 동작하며, bash, sh, zsh에서는 동작하지 않음